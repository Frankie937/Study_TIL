< 리눅스, 맥, 윈도우에서 도커환경 구축> 
* ubuntu 20.04에서 docker 설치하기
sudo add-apt-repository "deb [arch~~~ " 
-> 기본 우분투패키지 프로그램 서버와 다른 도커용 서버에서 도커를 다운로드 받을 수 있는데, 그 해당 도커 프로그램 서버 위치를 등록하는 명령 
sudo apt update 
-> 등록한 docker repository까지 포함하여 최신 패키지 리스트 업데이트 (인덱스 업데이트해주는)
sudo apt install docker-ce 
-> 도커 설치
sudo systemctl status docker 
-> 도커 실행중임을 확인 

도커는 권한이 많이 필요로 함  
리눅스에서 권한관리를 -> [ 사용자/그룹/아무나 ] 이런식으로 하는데, 
도커라는 '그룹'이 따로 있음
whoami로 현재 사용자가 누군지 확인하고, 그 현재 사용자를 도커그룹에 추가를 시키는 게 좋음! 
그 명령어 바로 아래 코드 치기
sudo usermod -aG docker ${USER} 
-> 이 코드 치고 exit으로 도커 서버를 끊고 다시 그 서버로 ssh로 다시 접속해서(ssh -i ~~.pem ubuntu@13.209.45.~ )
id -nG 
-> 이 코드 쳐서 현ID가 속한 그룹을 볼 수 있는데, 거기에 docker 그룹에 포함되어 있는지를 확인할 수 있음
-> 그러면 이제 sudo 없이 docker 명령어 바로 칠 수 있음(현 사용자가 도커그룹에 속해져서 권한이 많아졌기에) 

* 도커는 이렇게 도커 하나만을 다루는 명령어(docker)가 있고,  
사실 상용 서비스들은 도커를 여러 개를 만들어서 한 번에 실행하고 관리하는 것이 일반적인데 그 명령어가 docker compose 
그래서 docker-compose 관련 프로그램을 또 따로 설치해줘야 함 

* ubuntu 20.04 docker-compose 관련 프로그램을 따로 설치해줘야 함 
sudo curl -L "https://github.com/docker/compose/release/download/1.28.2/~~" -o /usr/local/bin/docker-compose
-> 1.28.2 이게 버전을 의미하는데, 최신 버전으로 하는 것은 추천하지 않음(강의 내용 상의 코드가 적용 안될 수도 있기 때문에)
-> curl -L 명령어: 특정 서버의 특정 프로그램을 특정 파일명으로 다운로드 하라는 명령어 (그래서, 해당 파일에 실행권한을 설정해줘야 함 --아래코드 확인)
sudo chmod +x /usr/local/bin/docker-compose
docker-compose --version 
-> 버전확인되면, docker-compose 설치 성공 ! 

<docker 주요 명령 익히기> 
* 도커는 리눅스 컨테이너 기술에서 기반하는 기술 
LXC(LinuX Containers) 
-단일 컴퓨팅 시스템에서 설치된 리눅스 운영체제 상에서, 다른 영역과 완전히 분리된 별도의 리눅스 시스템을 운영할 수 있는 리눅스 커널 기술
-리눅스 운영체제 레벨에서 영역과 자원 할당(CPU, 메모리, 네트워크)등을 분리하여, 마치 별도의 시스템처럼 사용할 수 있는 기술을 의미 
-> 다른 가상 시스템의 경우, 하드웨어 레벨에서 별도의 컴퓨터인 것처럼 분리해서 사용할 수 있는 기술도 있음. 이를 운영체제 레벨에서 할 수 있는 기술이라고 이해하면 쉬움 
-docker는 리눅스 커널에 LCX기술을 사용해서 
-> '리눅스 컨테이너'를 만들고(분리된 공간을 리눅스 컨테이너라고 부름)
-> 리눅스 컨테이너 상에 별도로 구성된 파일 시스템에 시스템 설정 및 응용 프로그램을 실행할 수 있도록 하는 기술을 정의한 것이라고 이해하면 됨 
(초기 docker는 LXC 기술을 기반으로 구현되었으나, 최근에는 별도 컨테이너 기술을 구현하여 사용하고 있음) 

** 도커 주요구성요소 
* docker engine
-도커는 서버/클라이언트 구조로 이루어짐 
-> 서버는 docker daemon process(데몬 프로세스) 형태로 동작함
(데몬이란, 보통 계속 실행 중인 프로그램으로 이해하면 됨(계속 떠있다고도 이야기 함))
-docker daemon process에 요청하기 위해, 프로세스간 통신 기법이 필요하며, docker는 이를 위해 Rest API를 사용함 
(참고: 더 깊은 이해를 위해서는 컴퓨터 공학 운영체제의 프로세스 구조와 프로세스 간 커뮤니케이션(IPC) 부분을 이해해야 함) 
-docker command는 일종의 클라이언트라고 이해하면 됨 
-> docker command를 내리면, 결국 내부적으로 Rest API를 사용해서, docker daemon process를 호출하는 방식 
-> 예) docker ps라고 명령하면, 내부적으로는 마치 다음 명령처럼 Rest API 호출 
http GET 'docker daemon process'/api-version/containers
=> 그렇기 때문에 도커가 실행되어 있어야 도커명령이 적용되어 실행되는 구조임!! 

* docker image 
-docker 컨테이너를 생성하기 위한 명령들을 가진 템플릿
-여러 이미지들을 layer로 쌓아서, 원하는 형태의 이미지를 만드는 것이 일반적임 
-> 예) ubuntu 이미지에, apache 웹서버 이미지를 얹어서, 웹서버 이미지를 만듦 

* docker container 
docker image가 리눅스 컨테이너 형태로 실행한 상태(instance)를 의미함 
docker daemon에 있는 커널에서 LXC로 리눅스 컨테이너를 생성한 후, 해당 컨테이너에 docker image에 포함된 명령을 실행하여, docker container를 만들고 실행함. 
docker container는 분리된 공간이므로, docker daemon process를 통해, 접속하 수도 있고 내부에 들어가서 코드수정, 재실행 등도 가능함. (결국 docker는 image와 container를 다뤄서, 작업한다고 이해하면 됨) 

[도커활용을 위한 추가 명령어 익히기] 


<도커 & 쿠버네티스 기초> 

<도커(Docker) 소개> 
-요즘 도커없이 개발하기 어려움 (도커는 지금 거의 사용하고 있음)

* 도커 개요
-가상화 기술을 본격적으로 표준화하게 된 계기 
-도커사용 전 : 개발환경만 세팅하는데 일주일 걸렸음 
(너무 복잡한 라이브러리 설치 필요, 프로덕션 환경과 로컬환경 다르고 등등..)

-도커 사용 -> 일관된 환경 보장 (생산성 향상) 개발 프로세스 환경, 배포 과정 등의 통일 하는데 좋음
(도커라는 기술 기반 위에서 쿠버네티스 기술이 활성화 되고 있음)
(요즘에는 도커 사용없이 개발하는 건 어려움)

*도커 필요 이유 
-> 애플리케이션을 개발, 제공 및 실행하기 위한 개방형 플랫폼
(애플리케이션을 인프라에서 분리 가능->소프트웨어에서 빠르게 제공 가능) 
-애플리케이션을 관리하는 것과 동일한 방식으로 인프라 관리 가능
-코드를 신속하게 전달, 테스트 및 배포하기 위한 Docker의 방법론을 활용하면 코드작성과 프로덕션 실행 사이의 지연을 크게 줄임
(도커를 사용 하면, 코드 개발하고 배포를 할 때 신경쓸 일이 줄어듦
예를 들어, 서버 관리할 때 서버에 어떠한 운영체제가 깔려있느냐에 따라 라이브러리 설치 문제 등의 여러 이슈들이 있음(로컬환경과 프로덕션 환경이 다르므로)
그러나, 도커를 사용하면 이러한 문제들 엄청나게 해소가 됨)

-도커는 빠르고 일관된 애플리케이션 제공 
-개발 수명주기 간소화 
-지속적 통합 및 지속적 배포 (CI/CD) 워크 플로에 적합함

(예제시나리오)
-개발자는 로컬에서 코드작성->도커컨테이너를 사용하여 동료와 작업을 공유(이미지 단위로)
-도커를 사용하여 애플리케이션을 테스트 환경으로 푸시하고 자동 및 수동 테스트를 실행함 
-개발자가 버그를 발견하면, 개발 환경에서 버그를 수정하고 테스트 및 검증을 위해 테스트 환경에 재배포 가능
-테스트가 완료되면 업데이트 된 이미지를 프로덕션 환경에 푸시하는 것만큼 간단하게 고객에게 수정 사항 제공 가능


-도커 데몬(dockerd): Docker API 요청을 수신하고 이미지, 컨테이너, 네트워크 및 볼륨과 같은 도커 객체를 관리함
데몬은 다른 데몬과 통신하여 도커 서비스를 관리할 수도 있음 

-도커 클라이언트(docker) : 많은 도커 사용자가 도커와 상호 작용하는 기본 방법
docker run과 같은 명령을 상요하면 클라이언트가이 명령을 dokerd(데몬)에 전송하여 실행
이 docker명령을 Docker API를 사용 
Docker 클라이언트는 둘 이상의 데몬과 통신할 수 있음

-도커 레지스트리(registry) : Docker 레지스트리는 Docker 이미지를 저장하는 곳. 
Docker Hub는 누구나 사용할 수 있는 공용 레지스트리. Docker는 기본적으로 Docker Hub에서 이미지를 찾도록 구성됨
자신의 개인 레지스트리를 실행할 수도 있음 
docker pull 또는 docker run 명령을 사용하면 구성된 레지스트리에서 필수 이미지를 가져옴. 
docker push 명령을 사용하면 이미지가 구성된 레지스트리로 푸쉬됨 

-도커 객체 : Docker를 사용하면 이미지(docker build하면 이미지가 형성되고-정적인 파일이 되는 것, 도커 레지스트리에 등록하는 단위), 컨테이너(이미지를 실행하면 생기는 것), 네트워크, 볼륨, 플러그인 및 기타 객체를 생성하고 사용하게 됨. 
이 섹션은 이러한 개체 중 일부에 대한 간략한 개요 

-도커 이미지: 이미지 도커 컨테이너를 만들기 위함 지침 읽기 전용 템플릿. 
(종종 이미지는 몇 가지 추가 사용자 정의와 함께 다른 이미지 기반으로 함.
예를 들어, 이미지를 기반으로 하는 이미지를 빌드할 수 ubuntu 있지만, Apache 웹 서버와 애플리케이션은 물론 애플리케이션을 실행하는 데 필요한 구성 세부사항도 설치 
->자신의 이미지를 만들거나 다른 사람이 만들고 레지스트리에 게시한 이미지만 사용 가능 
고유한 이미지 빌드하려면 이미지를 만들고 실행하는 데 필요한 단계를 정의하는 간단한 구문으로 Dockerfile을 만듦
(Dockerfile만 있는 경우는, 아주 작은 텍스트 파일이라고 보시면 되는데 이것만으로도 이미지 단위를 관리할 수 있음 -> 즉, 저렴하게 형상관리 가능)


-도커 컨테이너 : 컨테이너는 이미지의 실행 가능한 인스턴스. Docker API 또는 CLI를 사용하여 컨테이너 생성, 시작, 중지, 이동 또는 삭제 가능 
(실제로 리소스를 먹고 있는데 이 컨테이너가 되는 것, docker run을 하면 이미지가 컨테이너로 실행이 되는 것) 
(약간, 객체지향프로그래밍으로 비유하면, class가 이미지이고 인스턴스가 컨테이너로 보면 됨) 
컨테이너를 하나 이상의 네트워크에 연결하고나 스토리지를 연결하거나 현재 상태를 기반으로 새 이미지를 만들 수도 있음 


<쿠버네티스 기초> 

* 쿠버네티스 개요 (구글에서 주도적으로 개발해서 오픈)
-예를 들어, 게임 서버의 접속자 폭주로 인한 장애 등 
서버에 대한 스케일링을 할 때, 경험이 충분하지 않으면 이러한 장애들이 많이 발생 
서버를 스켈링하고 스켈 아웃하는 방식이 예전에는 조금 성숙하지 않아서 어려웠음
계속 발전되가면서 훨씬 편해짐 

*쿠버네티스 필요한 이유
-수직적 오토 스케일링(Vertical Pod Auto-scaler)
-수평적 오토 스케일링(Horizontal pod Auto-scaler)

